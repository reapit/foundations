import { Meta } from '@storybook/addon-docs'

<Meta title="Introduction" />

# Introduction

Welcome to Reapit Elements UI Library.

Within this Storybook, there are all the basic components and classes you will need to build clean, composable UI interfaces for the Reapit Marketplace and Platform.

## Getting Started

### Installation

Elements is distributed via NPM as a CommonJS or ESM module. Your first step is, with NodeJS installed, to run;

```bash
npm install @reapit/elements

# or for yarn users

yarn add @reapit/elements
```

You can then import the modules into your project in the normal way;

```ts
import { Input } from '@reapit/elements'

// Or for CommonJS users

const { Input } = require('@reapit/elements')
```

You will also need to add the exported stylesheet from the dist folder of the library, to the entry point of your application eg;

```ts
import '@reapit/elements/dist/index.css'

// CommonJS

require('@reapit/elements/dist/index.css')
```

or in a css file

```css
@import '~@reapit/elements/dist/index.css';
```

And that's it - the stylesheet will include the Inter Google Font and some basic defaults, with the component CSS classes providng the majority of the styles.

### Dependencies

From the outset, we have aimed to keep the library purely presentational with as few dependencies as possible. The basic reasoning for this is;

- Small footpint - we don't want to bloat your project.
- Developer flexibility - you can use your preferred libraries and frameworks alongside Elements, not competing against it.
- Limited vendor buy in - we are not depedent on other libraries update paths and API changes when developing Elements.

As such there is only one core dependency on the React side of the library - the Excellent [Linaria CSS in JS package](https://github.com/callstack/linaria). The reason for using this over other CSS pre-processors are as follows;

- Zero runtime so it's extremely performant.
- CSS extraction - we can export the CSS in our CSS at compile time.
- Friendly, semantic class names - the `camelCased` class names and `PascalCased` components can be output to readable `kebab-case` CSS classes, with no hashed ids.
- Tiny footprint - the only core dependency is linaria which compiles to less than 1kb.

Because the project is compiled, you should have no issues using Linaria components out the box. If you want to use it yourself alongside Elements, please see the [integration guide here](https://github.com/callstack/linaria/blob/master/docs/BUNDLERS_INTEGRATION.md).

Aside from Linaria, if you are using the React components, obviously you will need to have both `react` and `react-dom` as peer dependencies.

On the CSS side, there are no dependencies or external libraries.

### Using the Docs

When using this Storybook, it is worth drawing attention to the tabs at the top of the page - `docs` and `canvas`.

The `docs` tab is the best starting place in most cases as it includes usage documentation and commentry on each of the components. For React components we also display a `props` table and a `canvas` component that will allow you to copy-paste the JSX markup for use in your code.

The `canvas` tab is best used for inspecting the components and looking at how they behave in a browser-like environment. They do not display the markdown documentation, the props table or the copy-paste canvas, so please refer back to the `docs` tab for commentry on usage.

### Non React Users

One of our core motivators for the library was that while the library is built in React, we want to give the best possible experience for non-react users.

The base styles generated from the React code are all documented as CSS classes you can just add to any markup in any language. Additionally, care has been taken with the library so that where possible, all component behaviour in React can be mirrored in any JS framework or indeed, vanilla JS, by simply toggling available classes.

To view the rendered HTML markup of a React component, there are two options;

1. In the `canvas` tab, you can see in the bottom menu a HTML tab - this shows the output DOM of the page.
2. In the `docs` tab, each React example `canvas` has a corresponding custom component that is labeled `HTML of <<Story Name>>`. This both renders the HTML markup and offers the same copy-paste functionality as the React Canvas.

### Browser Support

Because of the extensive use of CSS Variables, and other modern CSS features like grid and flexbox, support is limited to modern browsers i.e. Chrome, Edge, Safari and Firefox.

When building for the Reapit Marketplace, your application will render in a Chromium browser, currently at version 69 although we expect this to upgrade to a more recent version in the coming months. We will always support the Reapit Marketplace Chromium version as a minimum version.

### Migrating from v3

Elements v4 is an evolution of v3 and has very few critical breaking changes other than deprecated props and CSS classes. The UI will change significantly however, where possible all changes are cosmetic and do not effect either markup or TypeScript definitions. Care has been taken to add all changes to the Changelog and we suggest you read this before upgrading.

v5 of Elements will include a number of breaking changes where unused props and CSS classes will be removed. Where this is planned, we have put `console.warn` notices in the codebase and annotated interfaces in the docs. You should look to fix these notices before upgrading to v5.

For most users, if you have used Elements out the box, it should be just a case of updating from v3 to v4 and making some light touch tweaks based on the changelog notes and console warnings.

### Migrating from v2

> Elements v2 is now deprecated and will only be supported for breaking changes via GitHub issues until the end of April 2024. We strongly recommend you migrate to v3 or v4 as soon as possible.

> Elements v3 is a ground-up re-write. Because of this, it is not possible to document all breaking changes as the API has changed fundamentally. v4 is based on the v3 codebase so it may be easier to migrate to v3 first and then v4.

If you are on version 2 of Elements and this is working for your application the first question is "why migrate"? As previously stated, v3 is a ground up re-write with better performance, radically smaller size, better docs and a more friendly API. You will also benefit from much longer term support, new features and of course all the benefits of our clean, professional in house design system.

We understand that because v3 is a re-write, migration will be some work so to make this easy to manage incrementally, we export the whole of Elements v3 from the v3 directory of Elements 2 e.g. to get a v3 button in the v2 library;

```tsx
import { Button } from '@reapit/elements/v3'
```

You will also need to import the v3 stylesheet **in addtion** to the v2 stylesheet already in your project. Exporting the v3 stylesheet from v2 is done like this;

```ts
import '@reapit/elements/v3/index.css'

// CommonJS

require('@reapit/elements/v3/index.css')
```

```css
@import '~@reapit/elements/v3/index.css';
```

This will mean you can update from v2 to v3 at your own pace.

The elements v2 components are detailed on a [separate Storybook here](https://elements-legacy.prod.paas.reapit.cloud).

### Issues

If you find a bug with any of the components, please report it through [this link](https://github.com/reapit/foundations/issues/new?assignees=&labels=bug%2C+needs-triage%2C+elements&template=bug_report.md&title=) to our Github Issues page.

We are also open to feature requests - in the same way please request [here](https://github.com/reapit/foundations/issues/new?assignees=&labels=external-request%2C+needs-triage%2C+elements&template=feature_request.md&title=) and if it makes sense with our roadmap and the wider design system, we will accept for development.
